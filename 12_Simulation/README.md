N = 6
양 끝 : 0.0, 5.5 
장애물 : 3.1, 2.4
좌,우 방향 장애물 존재 : x 값 동일
상,하 방향 장애물 존재 : y 값 동일


0 0 0 3 0 0
0 2 0 0 0 0
0 0 4 0 6 0
0 0 0 0 2 0
0 1 0 0 0 0
0 0 0 0 0 5

결과
0 0 0 3 0 0
0 2 0 0 0 0
0 0 4 0 6 0
0 6 0 0 2 0
0 1 0 0 0 0
0 0 0 0 0 5


0 0 # 3 0 #
0 2 # 0 0 #
# # 4 0 6 #
0 0 # 0 2 #
0 1 # 0 0 #
# # # # # 5

1 0 # # # 0
# 1 # # # 0
# # 1 5 # #
# # 5 1 # #
# # # # 1 0
# # # # 0 1

1. 1번 단방향
상 : 
하 :
좌 :
우 :

2. 2번 양방향
상하 :
좌우 :

3. 3번 직각방향
상우 :
우하 :
하좌 :
좌상 :

4. 4번 3방향
2.2
상 : 0.0 - 2.2  => 2-0 = 2개
하 : 5.5 - 2.2 => 5-2 = 3개
좌 : 0.0 - 2.2 = 2-0 = 2개
우 : 장애물 2.4 - 2.2 = 2-1 = 1개 (장애물 본인 제거)

좌상우 : 2+2+1 = 5
상좌하 : 2+2+3 = 7
좌하우 : 2+3+1 = 6
하우상 : 3+1+2 = 6

5. 5번 4방향
상하좌우 : 모든 방향이므로 모든 방향에 대해서 한다
=> 시간복잡도 : 6*4 = 24


- 6*8크기의 cctv 를 담는 Pair배열 생성 (0번 제외)
- cctv에 번호 별로 입력될 개수를 담는 일차원 int 배열 cctvCount
- 사무실 조건을 담을 board 이중 배열 선언
  - (크기는 N*M로 최대로 맞추고 0 = 사각지대, 1이상 5이하 : cctv, -1 : cctv 시야지대, 및 6 = 장애물)
- 사각지대 개수 count = 0
- 위치를 저장하는 Pair 클래스 생성

1. N, M의 크기를 저장 N, M 최대 8 
2. count = N * M
3. board 생성,  생성 N * M 크기
4. board 입력 + cctv 번호에 맞추어 [번호][cctvCount++]에 담기 +   
   count -=  장애물 발견 횟수, cctv 개수
=> O(N) : N*N 8*8
5. for문 5부터 1까지 반복 8*5*4*16


      1. 시작하는 번호 i 와 위치 값 pair를 받는 함수전달
      2. 전달받은 함수는 상하좌우의 값을 생성
      2-0. direction 배열 생성
      2-1. 4번 반복하는 for 문 생성
         - 상좌하우 한칸 이동한 값 생성
         - 이동한 값이 board 의 범위 안에 있는지 확인
            - 상 일때 
            - 0.y - x.y를 해서 상에 위치에 있는 시야 (count = 0)를 구함
            - 0부터 x-1까지 반복함
               - 만약 eysight[i][y] 값이 0이라면 count++
               - 만약 eysight[i][y] 값이 6이라면 count = 0
            - 종료 시 count값을 direction[0]에 저장

            - 하 일때
            - x.y - N.y 를 해서 하에 위치에 있는 시야 (count = 0)를 구함
             - N-1 부터 x+1까지 반복함
               - 만약 eysight[i][y] 값이 0이라면 count++
               - 만약 eysight[i][y] 값이 6이라면 count = 0
            - 종료 시 count값을 direction[2]에 저장

            - 좌 일때
            - x.0 - x.y 를 해서 좌에 위치에 있는 시야 (count = 0)를 구함
            - 0부터 y-1 까지 반복함
               - 만약 eysight[x][i] 값이 0이라면 count++
               - 만약 eysight[x][i] 값이 6이라면 count = 0
            - 종료 시 count값을 direction[1]에 저장

            - 우 일때
            - x.y - x.M 를 해서 우에 위치에 있는 시야 (count = 0)를 구함
            - M-1 부터 y+1까지 반복함
               - 만약 eysight[x][i] 값이 0이라면 count++
               - 만약 eysight[x][i] 값이 6이라면 count = 0
            - 종료 시 count값을 direction[3]에 저장
      2-2. 번호 cctvType 에 맞추어서 maxCount 값을 생성
         - cctvType == 1 일때 모든 direction 중에서 가장 큰 것을 maxCount로 저장
         - cctvType == 2 일때 
            direction 0+2 의 값과 direction 1+3 의 값을 비교해 큰 것을 maxCount로 저장
         - cctvType == 3 
            direction 0+1, 1+2, 2+3, 3+0 의 값을 비교해 큰 것을 maxCount로 저장
         - cctvType == 4
            direction 0+1+2, 1+2+3, 2+3+0, 3+0+1 의 값을 비교해 큰 것을 maxCount로 저장
         - cctvType == 5
            direction 0+1+2+3 의 값을 maxCount로 저장
         maxCount로 저장된 방향의 값들을 int[]에 저장
      2-3. count -= maxCount
      2-4. int[]에 저장된 방향 배열을 가지고 에 시야 표시 하기
         - for int[] size 만큼 반복
            i == 0 이라면 x,y에서 x 값을 감소시키면서 eysight값이 0이면 1로 바꿈
            i == 1 이라면 x,y에서 y 값을 감소시키면서 eysight값이 0이면 1로 바꿈
            i == 2 이라면 x,y에서 x 값을 증가시키면서 eysight값이 0이면 1로 바꿈
            i == 0 이라면 x,y에서 y 값을 증가시키면서 eysight값이 0이면 1로 바꿈

      


6. count 값을 출력하기

board 값 사용 안하면 버리기
시야지대와 cctv위치를 합쳐도되는지 확인
               
       





















